# 把数组排成最小的数

[链接](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。



我的解法1是暴力法，直接遍历所有可能的结果，找出最小值。具体流程是先用二维数组储存所有可能的排列结果，然后遍历所有结果找出最小值，最后把这个最小值转成string即可。但有一点要注意的是在求和的时候如果变量是int型，可能会溢出，所以要定义double型，最后转成string的时候要截掉小数点和小数点之后的字符。此方法时间和空间开销都很大，不建议。



我的解法2用的排序，只是在比较大小时是对两个字符串比较，要自定义比较规则。我的思路是这样的：比如比较字符串a(342)和字符串b(3423)，先一位位比较，然而直到a遍历结束二者都一样大。我们需要继续比较，要在a后面补位，那么补的值是多少呢？

以此例分析，要比较的两个拼成的数分别是ab和ba，即3423423和3423342，比较这两个数的大小即满足题意。比较过程：从第一位开始，3和3等，4和4等，2和2等，3和3等，4大于3，因此结果出来了。

由上述分析可知，a如果遍历到末尾了仍未分出大小，后面要依次补上b的元素，而因为b的前几位和a的所有位相等，所以补上b的元素等价于补上a的元素。因此遍历a和b字符串比较大小的过程如下：3=3，4=4，2=2，a遍历到末尾仍未分出大小，a的指针重新回到a[0]，继续比较a和b，然后当b遍历到末尾仍未分出结果，b同理指针回到b[0]。当满足此条件时不管二者是否相等都要停止比较：遍历次数等于a的size加上b的size的时候，因为两个数拼起来位数就是这么多。

关于排序可用任意算法，我的解法用的快排，其他所有排序算法均可。



官方解法思路等同于我的解法，只是官方解法直接比较的是两个拼好的数，代码没有我的解法这么复杂。