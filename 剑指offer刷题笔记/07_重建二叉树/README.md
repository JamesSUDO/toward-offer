# 重建二叉树

[链接](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=1)

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。



这个题，我没想出来有什么好的方法，然后看了书上的解析才把题解出来，我的代码参考了书上的原理，以下是书上的原理解读：

举书上的例子，例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，对应的二叉树如下：

```
         1
        / \
       2   3
      /   / \
     4   5   6
      \     /
       7   8
```



开始分析：二叉树的前序遍历，是先根节点，再左右两子树，中序遍历是先左子树再根节点再右子树。

我们可以先看二叉树的前序遍历，第一个元素1一定是二叉树的根节点，再看元素1在中序遍历数组中的位置，如果1左边的元素，一定是1的左子树的，右边的元素是1的右子树的。即第一步可以把前序遍历中1后面的元素分成两个子数组：{2，4，7}和{3，5，6，8}。

然后，处理两个子树，对于1的左子树{2，4，7}，紧挨着1的第一个元素2一定是1的左节点，结合二叉树的图可以明白；同理，对于1的右子树的{3，5，6，8}，第一个元素3一定是1的右节点。这样，1的两个节点找到了。

下一步，就是分别对以2节点为新的根节点的{2，4，7}和以3节点为新的根节点的{3，5，6，8}执行和前面一样的操作，进行一步步的递归操作。

总结下来，就是把以1为根节点的{1,2,4,7,3,5,6,8}分成左右两子树并分别找到左右两新根节点，再重复对新的两子树执行重复的操作，直到新的根节点左右都没有元素停止。